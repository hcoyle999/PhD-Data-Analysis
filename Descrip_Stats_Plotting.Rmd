---
title: "PHD-Data-Analysis"
output: html_document
---

# Analysising clinical and cognitive data across three time points in a sample of mild traumatic brain injury (mtbi) patients

# Hannah Coyle, hannah.coyle@monash.edu, January 2019

# R Markdown Instructions
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

## Command shortcuts
Move cursor to console = Ctrl + 2
Move cursor to command editor = Ctrl + 1
Clear console= Ctrl + L
Run the line in the command window = Command + Enter
Run whole script = Command + Shift + S
Click the **Knit** button to generate a document that includes both content as well as the output of any embedded R code chunks within the document

Other shortcutes are below
https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts

## Useful commands/things to know when getting started
getwd()- shows you where your wd is
sessionInfo() -gives you an overview of your version, packages loaded etc.
attach()- make the variables inside of data available to be called by name
detach ()- do the opposite of attach
install.packages () - installs packages for you (name must be in "")
library() - loads whatever package you need
par(mfrow=c(X,X)) - displays multiple plots on a page 
detach_package("XX", TRUE) - detach a package (sometimes r gets confused if you have too many loaded)
~ on mac is your home directory
r does not like \ only / 
%>% is the pipe operator (still learning how to use)

# General r setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
here<-"/Users/han.coyle/Documents/PHD-Data-Analysis/PHD-Data-Analysis"
setwd(here)
```

##Load libraries
```{load libraries, include=FALSE}
library(tidyverse) #formatting data for analysis
library(psych) #package for descriptive and analytic statistics
library(dplyr) #manipulating your data
library(ggplot2) #visualising your results
library(plyr) #manipulating your data (splitting, applying and combining)
library(finalfit) #create final tables whilst modelling and plotting- also useful for identifying missing data
library(naniar) # for summarising, visualising and manipulating missing data
```



## Opening my SPPS database and converting to R file
```{r Open SPSS, include=FALSE}
## the following is to ensure that the SPSS data is loaded correctly so you can see variable labels and value labels 
#load database as a list
setwd(here)
COMBINED_COG_PhD<-haven::read_spss("COMBINED_COG_PhD.sav",user_na=FALSE)
View(COMBINED_COG_PhD)
save(COMBINED_COG_PhD,file="~/Documents/PHD-Data-Analysis/PHD-Data-Analysis/COMBINED_COG_PhD.Rdata")
```

## Calculating descriptive statistics
```{r Descriptive statitics,include=FALSE}
## calculating mean of variables (na.rm is to ignore misisng values,and round is to get it to two decimal places)
round(mean(x=COMBINED_COG_PhD$age,na.rm=TRUE),digits=2)
round(mean(x=COMBINED_COG_PhD$days_post,na.rm=TRUE),digits=2)

# larger range of descriptive statistics(using psych package)
describe(age)
# looking at descriptive stats for range of
demo <-cbind(age,education,HADS_Total_BL)
describe(demo)
# change column names
colnames(demo)<- c('Age','Level of Education','Anxiety/Depression')
describe(demo)
#by group
describeBy(demo,group=group)

```

## Data transformation (filter, arrange, select etc) 
```{r Transforming my data, include=FALSE}

#remove unecessary row with empty data (but check this when update df with additional participants)

#COMBINED_COG_PhD_1<-COMBINED_COG_PhD %>% remove_empty("rows")
#code above should work but is not- this is a better option because it is not locked to a particular row

#quick and dirty approach
COMBINED_COG_PhD <- COMBINED_COG_PhD[-c(55),]

#tidying up variable names
names(COMBINED_COG_PhD) <- tolower(names(COMBINED_COG_PhD))

# If I need to rename an individual column in the dataset
#colnames(COMBINED_COG_PhD)[colnames(COMBINED_COG_PhD) == 'Old_Complicated_Name'] <- 'new.simple.name'


# practicing filtering (this just prints out results, need <- to make a variable, If you want to do both, you can wrap the assignment in parentheses)
age_over_30 <- filter(COMBINED_COG_PhD,age > 30)
(age_under_30 <-filter(COMBINED_COG_PhD, age < 30))

#make dfs for my two groups
control_df <- filter(COMBINED_COG_PhD,group == 1)
mtbi_df <- filter(COMBINED_COG_PhD,group == 2)

#to filter effectively need to know the operators, e.g. >, >=, <, <=, != (not equal), and == (equal).

#filter() only includes rows where the condition is TRUE; it excludes both FALSE and NA values. If you want to preserve missing values, ask for them explicitly:

MFI_10<-filter(COMBINED_COG_PhD,MFI_GF_BL> 10 |is.na(MFI_GF_BL))

# arrange data (instead of selecting rows it changes their order)
arrange(control, age, education, sex)
#organising in descending order
arrange(control, desc(age))

#select data
 control_dem<-select(control, code,intials, age, education, sex)
 #if want to select all columns between two variables use
  control_dem<-select(control, code:education)
#can rename a column  
 COMBINED_COG_PhD <- rename(COMBINED_COG_PhD,c("intials" = "initials"))
  
#access df by row and or colum
  #access all rows, just age column
  COMBINED_COG_PhD[,'age']
  #access just row 1, all column
  COMBINED_COG_PhD[1,]
  

#add new variables with "mutate"
  #e.g. want a df with just MFI data in it
  MFI_df <- select(COMBINED_COG_PhD, code, intials, starts_with("MFI"))
  #create new variables with diff scores and add these to the df
  MFI_df <- mutate(MFI_df,
        bsl_T1_MFI_GF = MFI_GF_T1 - MFI_GF_BL,
        bsl_T2_MFI_GF = MFI_GF_T2 - MFI_GF_BL)
  #If you only want to keep the new variables, use transmute():
  MFI_df_diff<-transmute(MFI_df, bsl_T1_MFI_GF = MFI_GF_T1 - MFI_GF_BL, bsl_T2_MFI_GF = MFI_GF_T2 - MFI_GF_BL)
  
  #to create a new column and rename it
  MFI_df$newcolumn <- sqrt(MFI_df$MFI_GF_BL)
  colnames(MFI_df)[colnames(MFI_df) == 'newcolumn'] <- 'sqrt'
  
  #To get grouped summaries
  #first create new df with variables you are interested in seeing 
  group_dem <- group_by(COMBINED_COG_PhD, code, initials, age, education)
  #summarise and apply by group
  summarise(group_dem, meanRPQ = mean(RPQ_13_BL, na.rm = TRUE))
  
  #Combining operations by pipe (makes code easier to read and you dont have to name each intermediate data frame) - this produces a df with the mean RPQ symptom score for control and mtbi and mean coding score.
  # Also good to include a count (n()), or a count of non-missing values (sum(!is.na(x))). That way you can check that you’re not drawing conclusions based on very small amounts of data.
  sympt_speed <- group_dem %>% group_by(group) %>% summarise (count=n(), symptoms= mean(RPQ_13_BL, na.rm=TRUE), processingspeed=mean(Coding_BL,na.rm=TRUE))
  
  #If you need to remove grouping, and return to operations on ungrouped data, use ungroup().
  sympt_speed %>% 
  ungroup()  
  summarise(sympt_speed)

  #Can also do grouped mutates and filters (see section 5.7 of https://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise for info)

  
  # worked example
```
```{r characterising/dealing with missing data}
#glimpse function
#The function summarises a data frame or tibble by numeric (continuous) variables and factor (discrete) variables. The dependent and explanatory  are for convenience. Pass either or neither e.g. to summarise data frame or tibble:

# create explanatory and dependent variables to see specifics  
explanatory = c ("age", "education", "sex")
dependent = "WTAR"
ff_glimpse(COMBINED_COG_PhD,dependent,explanatory)

#whole df
COMBINED_COG_PhD %>% ff_glimpse()
Coding_long_df %>% ff_glimpse()
#plot missing values
Coding_long_df %>% 
  missing_plot()

#can also use ggplot
ggplot(COMBINED_COG_PhD, aes( x=age, y= Coding_T1)) +
  geom_point()
# get a warning message saying X missing values
ggplot(COMBINED_COG_PhD, aes( x=age, y= Coding_T1)) +
  geom_miss_point()

#geom_miss_point() has shifted the missing values to now be 10% below the minimum value. The missing values are a different colour so that missingness becomes pre-attentive
ggplot(data = COMBINED_COG_PhD,
       aes(x = age,
           y = Coding_T1)) + 
  geom_miss_point() + 
  facet_wrap(~group, ncol = 2) + 
  theme(legend.position = "bottom")

#shadow matrix for viewing missingness
as_shadow(COMBINED_COG_PhD)
bind_shadow(COMBINED_COG_PhD)

#visualise missingness
COMBINED_COG_PhD %>%
  bind_shadow() %>%
  ggplot(aes(x = age,
             fill = Coding_T1_NA)) + 
  geom_density(alpha = 0.5)

#visualise for each variable
gg_miss_var(COMBINED_COG_PhD)

#quick stats on missingness for whole df (for cases, rows, variables- use help function to see it all)
pct_miss(COMBINED_COG_PhD)
pct_complete(COMBINED_COG_PhD)
#or for variable
n_miss(COMBINED_COG_PhD$Coding_T2)

#numerical summaries (**very helpful - could easily turn into a df **)
miss_var_summary(COMBINED_COG_PhD)
miss_case_summary(COMBINED_COG_PhD)

#numerical summaries by group
group_miss_var <- COMBINED_COG_PhD %>% 
  group_by(group) %>% 
  miss_var_summary

#looking for patterns of missingness
COMBINED_COG_PhD %>% 
  missing_pattern(dependent,explanatory)

## Plotting from online tutorial- not using ggplot
```{r Plotting my data, include=FALSE}
## using regular plot functions
## when you just want to type in the variables
attach(COMBINED_COG_PhD)
## plot adding headings- scatterplot
plot(age,WTAR,main="Age vs WTAR",xlab="WTAR",ylab="age(years)")
#draw a line
abline(0, 1)
#change from circles (1 Circle, 2 Triangle,3 Plus,4 Cross, 5 Diamond, 6 Reverse Triangle etc)
plot(age,WTAR,main="Age vs WTAR",xlab="WTAR",ylab="age(years)",pch=3)

#plot just control group
plot(age[group ==1],WTAR[group == 1],col="Red")

#plot both groups on top of each other
points(age[group ==2],WTAR[group == 2],col="blue")

#plot groups side by side (two windows)
par(mfrow = c(1,2))
plot(age[group ==1],WTAR[group == 1],main= "Control",xlim=c(0,50),ylim=c(0,45))
plot(age[group ==2],WTAR[group == 2],main= "mTBI",xlim=c(0,50),ylim=c(0,45))

mtext(text="WTAR",side=2, adj=1)

#go back to only one window
par(mfrow=c(1,1))

#timeseries plotting ( but for my data it will be for participants)
  plot(COMBINED_COG_PhD$HADS_Total_BL)
  plot(COMBINED_COG_PhD$HADS_Total_BL[group==1])
  hist(age)
  hist(age, breaks=5)
  
  ##box plots
  boxplot(age)
  boxplot(age [group==1],main="Control")
  #box plots side by side
  par(mfrow=c(1,2))
  boxplot(age [group==1],main="Control",ylim=c(15,55))
  boxplot(age [group==2],main="mTBI",ylim=c(15,55))
  
  par(mfrow=c(1,1))
  boxplot(age ~ LOC)
  
  #another way to do this is to use the ~ symbol, (e.g. age by group)
  boxplot(age ~ group, main= "Boxplot of age by group")
```


## ggplot Plotting 
```{r ggplot for my data, include=FALSE}
#Note that putting your entire ggplot code in brackets () creates the graph and then shows it in the plot viewer. If you don’t have the brackets, you’ve only created the object, but haven’t visualized it. You would then have to call the object such that it will be displayed by just typing barplot after you’ve created the “barplot” object.

#plotting two continuous variables
#scatterplots
ggplot(COMBINED_COG_PhD,mapping=aes(x=age, y=education)) + 
geom_point(colour=group)

ggplot(COMBINED_COG_Phd,mapping=aes(x=Coding_BL, y=SymbolSearch_BL)) +
geom_point(colour=group)
#histograms 
ggplot(COMBINED_COG_PhD, mapping=aes(x = education, y=age))+ geom_histogram(stat="identity")
# By default, geom_bar uses stat="count" which makes the height of the bar proportion to the number of cases in each group (or if the weight aethetic is supplied, the sum of the weights). If you want the heights of the bars to represent values in the data, use stat="identity" and map a variable to the y aesthetic.

ggplot(COMBINED_COG_PhD,aes (x=age), na.rm=FALSE) + geom_histogram(binwidth=1)
#line graphs

```
## Worked example (means to ggplot)
```{r practicing with coding data- shaping df, means and ggplot}
#prac example of line graph with means from coding across BL-T2 for both groups
#To get grouped summaries
  #first create new df with variables you are interested in seeing 
BL_T2_coding <- select(COMBINED_COG_PhD, code, intials, Coding_BL, Coding_T1, Coding_T2)
  #summarise and apply by group
  #BL_T2_coding %>%summarise(BL_T2_coding)
  #calculate means
  library(plyr)
  BL_T2_coding <-ddply (BL_T2_coding, .(group), summarize,  BL=mean(Coding_BL,na.rm=TRUE), T1=mean(Coding_T1,na.rm=TRUE), T2=mean(Coding_T2,na.rm=TRUE))
  
  #reshape the datafram
  library(reshape2)
  meltdf <- melt(BL_T2_coding,id.vars  ="group", variable.name = "timepoint",na.rm=TRUE)
  #remove haven labelling (you need to do this because when you import from SPSS you have all varaible value labels which then ggplot can't read)
  library(labelled)
  meltdf_1<-remove_labels(meltdf)
  
  #If you want to change the colum names
  #colnames(meltdf_1)<- c("Group","Timepoint","Processing Speed")
  
  #make a plot
  base<-ggplot(meltdf_1,aes(x = timepoint,y = value, colour= group)) + 
    geom_point(size=2) +
    geom_smooth () 
  ## this next step is changing parts of the graph- see page 181 of pdf book for info)  
    base + 
    theme(
      legend.background = element_rect(
      fill = "lemonchiffon",
      colour = "grey50",
      size = 1
      ))
    
## next step is to change Axis labels and to remove the group legend- or change it to say control and mTBI
    
    #can make plots with code or with the help of the esquisse package
    esquisse::esquisser() #loads the GUI for ggplot2 (!!)
    #https://github.com/dreamRs/esquisse/blob/master/README.md 
    
    ## gg theme assist is another helpful addin
    #To edit ggplot2 themes, just highlight a ggplot2 object in your current script and     run the Addin from the Addins menu. ggplot2 will analyze your current plot, update      its defaults to your current specification and give you a preview. 
    

```


# Visualising data longitudinally with box plots and in different groups
```{r visualising data longitudinally}
#visualising the data- processing speed
par(mfrow=c(1,2))
boxplot(control_df$Coding_BL,control_df$Coding_T1,control_df$Coding_T2,main= "Processing Speed",names=c("BL","T1","T2"),xlab="Control")
boxplot(mtbi_df$Coding_BL,mtbi_df$Coding_T1,mtbi_df$Coding_T2,main= "Processing Speed",names=c("BL","T1","T2"),xlab="mTBI")

# visualising the data longitudinally- digit span total and saving as a .png file in Figures folder
png(file="~/Documents/PHD-Data-Analysis/Analysis/Figures/boxplot_DSB.png")
par(mfrow=c(1,2))
boxplot(control_df$SS_total_BL,control_df$SS_total_T1,control_df$SS_total_T2,main= "Digit Span Total ",names=c("BL","T1","T2"),xlab="Control")
boxplot(mtbi_df$SS_total_BL,mtbi_df$SS_total_T1,mtbi_df$SS_total_T2,main= "Digit Span Total",names=c("BL","T1","T2"),xlab="mTBI")

par(mfrow=c(1,2))
boxplot(control_df$SS_bck_BL,control_df$SS_bck_T1,control_df$SS_bck_T2,main= "Digit Span BWD ",names=c("BL","T1","T2"),xlab="Control")
boxplot(mtbi_df$SS_bck_BL,mtbi_df$SS_bck_T1,mtbi_df$SS_bck_T2,main= "Digit Span BWD",names=c("BL","T1","T2"),xlab="mTBI")
dev.off()

##ideally would prefer to do this in ggplot but one thing at a time.
